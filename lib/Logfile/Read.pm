
package Logfile::Read;

=head1 NAME

Logfile::Read - read log files

=head1 SYNOPSIS

	use Logfile::Read ();
	my $file = new Logfile::Read('/var/log/messages');
	while (<$file>) {
		# process the line
	}

and later in different process

	my $file = new Logfile::Read('/var/log/messages');

and continue reading where we've left out the last time. Also possible
is to explicitly save the current position:

	my $file = new Logfile::Read('/var/log/messages',
		{ autocommit => 0 });
	my $line = $file->getline();
	$file->commit();

=cut

use strict;
use warnings FATAL => 'all';

our $VERSION = '0.1';

use Symbol ();
use IO::File ();
use Digest::SHA ();
use File::Spec ();
use Fcntl qw( O_RDWR O_CREAT );

sub new {
	my $class = shift;

	my $self = Symbol::gensym();
	bless $self, $class;
	tie *$self, $self;

	if (@_) {
		$self->open(@_) or return;
	}

	return $self;
}

my $STATUS_SUBDIR = '.logfile-read-status';
sub open {
	my $self = shift;

	my $filename = shift;
	if (@_ and ref $_[-1] eq 'HASH') {
		${ *$self }->{opts} = pop @_;
	}
	if (not exists ${ *$self }->{opts}{autocommit}) {
		${ *$self }->{opts}{autocommit} = 1;
	}

	my $fh = new IO::File;
	$fh->open($filename, @_) or return;

	${ *$self }->{_fh} = $fh;

	my $offset = $self->_load_offset_from_status($filename);
	return unless defined $offset;
	$fh->seek($offset, 0);
	1;
}

sub _fh {
	${ *{$_[0]} }->{_fh};
}

sub _load_offset_from_status {
	my ($self, $log_filename) = @_;
	${ *$self }->{filename} = $log_filename;

	my $status_filename = Digest::SHA::sha256_hex($log_filename);
	my $status_path = File::Spec->catfile($STATUS_SUBDIR, $status_filename);
	if (not -d $STATUS_SUBDIR) {
		mkdir $STATUS_SUBDIR, 0775;
	}
	my $status_fh = new IO::File $status_path, O_RDWR | O_CREAT;
	if (not defined $status_fh) {
		warn "Error reading/creating status file [$status_path]\n";
		return;
	}
	${ *$self }->{status_fh} = $status_fh;

	my $status_line = <$status_fh>;
	my $offset = 0;
	if (defined $status_line) {
		if (not $status_line =~ /^File \[(.+)\] offset \[(\d+)\]\n/) {
			warn "Status file [$status_path] has bad format\n";
			return;
		}
		my $check_filename = $1;
		$offset = $2;
		if ($check_filename ne $log_filename) {
			warn "Status file [$status_path] is for file [$check_filename] while expected [$log_filename]\n";
			return;
		}
	} else {
		$self->_save_offset_to_status($offset);
	}

	return $offset;
}

sub _save_offset_to_status {
	my ($self, $offset) = @_;
	my $log_filename = ${ *$self }->{filename};
	my $status_fh = ${ *$self }->{status_fh};
	$status_fh->seek(0, 0);
	$status_fh->printflush("File [$log_filename] offset [$offset]\n");
	$status_fh->truncate($status_fh->tell);
}

sub _close_status {
	my ($self, $offset) = @_;
	my $status_fh = delete ${ *$self }->{status_fh};
	$status_fh->close() if defined $status_fh;
}

sub getline {
	my $fh = $_[0]->_fh;
	if (defined $fh) {
		return $fh->getline();
	} else {
		return undef;
	}
}

sub getlines {
	my $self = shift;
	my @out;
	while (1) {
		my $l = $self->getline();
		if (not defined $l) {
			last;
		}
		push @out, $l;
	}
	@out;
}

sub commit {
	my $self = shift;
	my $fh = ${ *$self }->{_fh};
	my $offset = $fh->tell;
	$self->_save_offset_to_status($offset);
}

sub close {
	my $self = shift;
	if (${ *$self }->{opts}{autocommit}) {
		$self->commit();
	}
	$self->_close_status();
	my $fh = delete ${ *$self }->{_fh};
	$fh->close() if defined $fh;
}

sub TIEHANDLE() {
	if (ref $_[0]) {
		# if we already have object, probably called from new(),
		# just return that
		return $_[0];
	} else {
		my $class = shift;
		return $class->new(@_);
	}
}

sub READLINE() {
	goto &getlines if wantarray;
	goto &getline;
}

sub CLOSE() {
	my $self = shift;
	$self->close();
}

sub DESTROY() {
	my $self = shift;
	$self->close();
}

1;

=head1 DESCRIPTION

Log files are files that are generated by various running programs.
They are generally only appended to. When parsing information from
log files, it is important to only read each record / line once,
both for performance and for accounting and statistics reasons.

The C<Logfile::Read> provides an easy way to achieve the
read-just-once processing of log files.

The module remembers for each file the position where it left
out the last time, in external status file, and upon next invocation
it seeks to the remembered position.

=head1 TO DO

The backlog / to do list includes:

* use checksum to verify that we are indeed returning to the same
file we've read the last time, that the file was not recycled;

* support layers;

* support archived / rotated files.

=head1 METHODS

=over 4

=item new()

=item new( FILENAME [,MODE [,PERMS]], [ { attributes } ] )

=item new( FILENAME, IOLAYERS, [ { attributes } ] )

Constructor, creates new C<Logfile::Read> object. Like C<IO::File>,
it passes any parameters to method C<open>; it actually creates
an C<IO::File> handle internally.

Returns new object, or undef upon error.

=item open( FILENAME [,MODE [,PERMS]], [ { attributes } ] )

=item open( FILENAME, IOLAYERS, [ { attributes } ] )

Opens the file using C<IO::File>. If the file was read before, the
offset where the reading left out the last time is read from an
external file in the ./.logfile-read-status directory and seek is
made to that offset, to continue reading at the last remembered
position.

Returns true, or undef upon error.

The attributes are passed as an optional hashref of key => value
pairs. The supported attribute is

=over 4

=item autocommit

Value 1 (the default) means that position is saved when the object is
closed via explicit close() call, or when it is destroyed.

Value 0 means that no saving takes place; you need to save explicitly
using the commit() method.

=back

=item commit()

Explicitly save the current position.

Returns true, or undef upon error.

=item close()

Closes the internal filehandle. It stores the current position
in an external file in the ./.logfile-read-status directory.

Returns true, or undef upon error.

=item getline()

Line <$fh> in scalar context.

=item getlines()

Line <$fh> in list context.

=back

=head1 AUTHOR AND LICENSE

Copyright (c) 2010 Jan Pazdziora.

Logfile::Read is free software. You can redistribute it and/or modify
it under the terms of either:

a) the GNU General Public License, version 2 or 3;

b) the Artistic License, either the original or version 2.0.

